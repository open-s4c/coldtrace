diff --git a/src/mod/self.c b/src/mod/self.c
index 5c1f008..593dc4e 100644
--- a/src/mod/self.c
+++ b/src/mod/self.c
@@ -49,7 +49,7 @@ struct self {
     metadata_t md;
     struct rbnode map_node;
     struct quack_node_s retired_node;
-    pthread_t pid;
+    uint64_t oid;
     thread_id tid;
     struct rbtree tls;
     int guard;
@@ -177,6 +177,26 @@ _thread_cache_del(void)
         abort();
 }
 
+static uint64_t
+_thread_oid(void) {
+#ifdef SELF_PTHREAD_SELF
+    return (uint64_t) pthread_self();
+#else
+    return (uint64_t) gettid();
+#endif
+}
+
+static bool
+_thread_dead(uint64_t id) {
+#ifdef SELF_PTHREAD_SELF
+    return pthread_kill((pthread_t)id, 0) != 0;
+#else
+    return kill(id, 0) != 0;
+#endif
+
+}
+
+
 DICE_HIDE struct self *
 _create_self()
 {
@@ -184,7 +204,7 @@ _create_self()
     self        = mempool_alloc(sizeof(struct self));
     self->guard = 0;
     self->tid   = vatomic64_inc_get(&_threads.count);
-    self->pid   = pthread_self();
+    self->oid   = _thread_oid();
     _tls_init(self);
     return self;
 }
@@ -202,9 +222,9 @@ _self_cmp(const struct rbnode *a, const struct rbnode *b)
 {
     const struct self *ea = container_of(a, struct self, map_node);
     const struct self *eb = container_of(b, struct self, map_node);
-    if ((uint64_t)ea->pid == (uint64_t)eb->pid)
+    if (ea->oid == eb->oid)
         return 0;
-    return ((uint64_t)ea->pid <= (uint64_t)eb->pid);
+    return ea->oid <= eb->oid;
 }
 
 static void
@@ -217,9 +237,9 @@ _init_threads(void)
 }
 
 static struct self *
-_thread_map_find(pthread_t pid)
+_thread_map_find(uint64_t oid)
 {
-    struct self key = {.pid = pid};
+    struct self key = {.oid = oid};
 
     caslock_acquire(&_threads.lock);
     struct rbnode *item = rbtree_find(&_threads.map, &key.map_node);
@@ -251,14 +271,14 @@ static struct self *
 _get_self(void)
 {
     struct self *self = _thread_cache_get();
-    return self ? self : _thread_map_find(pthread_self());
+    return self ? self : _thread_map_find(_thread_oid());
 }
 
 static void
 _retire_self(struct self *self)
 {
     assert(self);
-    assert(!self->retired);
+    assert (!self->retired);
     self->retired = true;
     _thread_cache_del();
     quack_push(&_threads.retired, &self->retired_node);
@@ -275,10 +295,10 @@ static void _cleanup_threads(void);
         self->guard++;                                                         \
         self->md = (metadata_t){0};                                            \
         log_debug(">> [%lu:0x%lx] %u_%u: %d", self_id(&self->md),              \
-                  (uint64_t)pthread_self(), chain, type, self->guard);         \
+                  _thread_oid(), chain, type, self->guard);         \
         PS_PUBLISH(chain, type, event, &self->md);                             \
         log_debug("<< [%lu:0x%lx] %u_%u: %d", self_id(&self->md),              \
-                  (uint64_t)pthread_self(), chain, type, self->guard);         \
+                  _thread_oid(), chain, type, self->guard);        \
         self->guard--;                                                         \
     } while (0)
 
@@ -293,7 +313,7 @@ _self_handle_before(const chain_id chain, const type_id type, void *event,
         self_guard(CAPTURE_BEFORE, type, event, self);
     else {
         log_info(">>> [%lu:0x%lx] %u_%u: %d", self_id(&self->md),
-                 (uint64_t)pthread_self(), chain, type, self->guard);
+                 _thread_oid(), chain, type, self->guard);
     }
 
     assert(self->guard >= 0);
@@ -313,7 +333,7 @@ _self_handle_after(const chain_id chain, const type_id type, void *event,
             _cleanup_threads();
     } else {
         log_debug("<<< [%lu:0x%lx] %u_%u: %d", self_id(&self->md),
-                  (uint64_t)pthread_self(), chain, type, self->guard);
+                  _thread_oid(), chain, type, self->guard);
     }
 
     assert(self->guard >= 0);
@@ -331,7 +351,7 @@ _self_handle_event(const chain_id chain, const type_id type, void *event,
         self_guard(CAPTURE_EVENT, type, event, self);
     else {
         log_debug("!!! [%lu:0x%lx] %u_%u: %d", self_id(&self->md),
-                  (uint64_t)pthread_self(), chain, type, self->guard);
+                  _thread_oid(), chain, type, self->guard);
     }
 
     assert(self->guard >= 0);
@@ -381,10 +401,7 @@ _cleanup_threads(void)
 
         struct self *self = container_of(item, struct self, retired_node);
 
-        // pthread_kill with signal 0 does not do anything with the thread, but
-
-        // if an error indicates the thread does not exist.
-        if (pthread_kill(self->pid, 0) != 0) {
+        if (_thread_dead(self->oid)) {
             _self_handle_event(CAPTURE_EVENT, EVENT_SELF_FINI, 0, self);
             _thread_map_del(self);
             _destroy_self(self);
@@ -394,7 +411,7 @@ _cleanup_threads(void)
 }
 
 static void
-_cleanup_thread(pthread_t pid)
+_cleanup_thread(uint64_t oid)
 {
     struct quack_node_s *item = quack_popall(&_threads.retired);
     struct quack_node_s *next = NULL;
@@ -404,7 +421,7 @@ _cleanup_thread(pthread_t pid)
 
         struct self *self = container_of(item, struct self, retired_node);
 
-        if ((uint64_t)self->pid != (uint64_t)pid)
+        if (self->oid != oid)
             quack_push(&_threads.retired, item);
         else {
             _self_handle_event(CAPTURE_EVENT, EVENT_SELF_FINI, 0, self);
